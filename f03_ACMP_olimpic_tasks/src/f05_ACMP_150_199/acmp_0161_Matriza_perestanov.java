package f05_ACMP_150_199;

/* 	Восстановление перестановки	(Время: 1 сек. Память: 16 Мб Сложность: 44%)
Перестановкой из N элементов называется упорядоченный набор из N различных чисел от 1 до N.
Пусть дана перестановка π. Обозначим φ[i] - количество таких j, что π[j] > π[i], а j < i. φ называется таблицей инверсий 
перестановки π.
	Требуется по данной таблице инверсий восстановить перестановку.
	Входные данные
В первой строке входного файла INPUT.TXT записано число 0 < N ≤ 2000 - порядок перестановки. Во второй строке записана таблица
инверсий.
	Выходные данные
В выходной файл OUTPUT.TXT выведите искомую перестановку.
Пример
№	INPUT.TXT	OUTPUT.TXT
1	3
	0 0 2	2 3 1		*/

/* А разве таблице инверсий 002 соответствует перестановка 231? Не понимаю почему не 213...
     Потому что первым числом всегда идет 0, вторым 0 тут идет, т.к. левее 3ки нет больших ее значений, ну а на 3м месте 2 т.к. 
     все значения левее больше единицы. */

import java.util.*;
import java.io.*;

public class acmp_0161_Matriza_perestanov	{
	
	/* Состав вектора и таблицы инверсий для цифровой перестановки P=(5,9,1,8,2,6,4,7,3) показан в следующем примере, где для 
	 наглядности индексированы позиции всех элементов:	
	 Таблица 1    
j	1	2	3	4	5	6	7	8	9
pj	5	9	1	8	2	6	4	7	3
Vj	0	0	2	1	3	2	4	2	6
Wj	2	3	6	4	0	2	2	1	9
Перестановка - p[]
Вектор инверсии	перестановки - v[]
Матрица инверсии перестановки - w[] 
V8=2, потому что слева от элемента P8=7 в перестановке есть 2 элемента P2=9 и P4=8 с большим значением,чем 7. 
W8=1,потому что слева от элемента со значением 8 (это P4) в перестановке имеется только 1 элемент (P2=9), значение которого больше,
чем 8. 
Для любой перестановки значения компонентов вектора и таблицы инверсий связаны следующими соотношениями:
V1 = Wn = 0; Vj = Wi | i = Pj; Wj = Vi | Pi = j.  */
	 
	 
	 /* Восстановление перестановки по таблице инверсий
Пример. Восстановить перестановку по таблице инверсий	[7,3,0,2,1,0,1,0]
Решение.
Перестановка содержит 8 номеров. Восстановление начинаем с числа 8. Ставим это число на неопределенное пока место
	[   8    ]
В позиции 7 в таблице инверсий стоит число 1, следовательно, 7 стоит правее 8.
	[   8   7  ].
В позиции 6 в таблице инверсий стоит 0, следовательно, 6 стоит левее всех уже поставленных чисел
	[  6  8   7  ].
В позиции 5 в таблице инверсий стоит число 1, следовательно, 5 стоит правее 6.
	[  6  5  8   7  ].
В позиции 4 в таблице инверсий стоит 2, следовательно, 4 стоит правее двух поставленных чисел, считая слева
	[  6  5  4 8   7  ].
В позиции 3 в таблице инверсий стоит 0, следовательно, 3 стоит левее всех уже поставленных чисел
	[3  6  5  4 8   7  ].
В позиции 2 в таблице инверсий стоит 3, следовательно, 2 стоит правее трех поставленных чисел, считая слева
	[3  6  5  2  4 8   7  ].
И, наконец, в первой позиции стоит 7. Ставим 1 на последнем месте, так, что перед 1 будет 7 чисел, больших 1. Получаем искомую перестановку
	[3,6,5,2,4,8,7,1].		. 	 */

public static void main(String[] args) throws IOException {
	Scanner sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));
	int N = sc.nextInt();
	
	int arr[] = new int[N+1];
	for (int i =1; i<=N; i++) arr[i] = sc.nextInt();
	System.out.println(Arrays.toString(arr));
	
	int res[][] = new int[2][2*N+1];
	res[0][0] = 0;
	for (int i =1; i<2*N+1; i++) {
		res[0][i] = res[0][i-1] + 1;
	}
	/*	9
		2 3 6 4 0 2 2 1 9		 */
	
	res[1][N] = N;
	for (int i =0; i<2; i++) System.out.println(Arrays.toString(res[i]));
	System.out.println();
	int positionOfLeftChisla = N;
	int positionOfRightChisla = N;
	
	for (int i = N-1; i>0; i--) {
		int a = arr[i];
		System.out.println("a = " + a);
		if (a == 0) {
			res[1][positionOfLeftChisla - 1] = i;
			positionOfLeftChisla--;
		}
		else {
			if ((positionOfLeftChisla + a) >positionOfRightChisla) {
				res[1][positionOfRightChisla + 1] = i;
				positionOfRightChisla++;
			}
			else {
				for (int y = positionOfRightChisla; y>=(positionOfLeftChisla + a); y--) {
					res[1][y+1] = res[1][y];
				}
				res[1][positionOfLeftChisla + a] = i;
				positionOfRightChisla++;
			}
		}
		for (int h = 0; h<2; h++) System.out.println(Arrays.toString(res[h]));
		System.out.println();
	}
	
	PrintWriter o = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	if (arr[N] !=0) {
		for (int h = positionOfLeftChisla; h<=positionOfRightChisla; h++) {
			System.out.println(res[1][h] + " ->");
			o.print(res[1][h] +" ");
	}
	}
	o.flush();
	o.close();
}
}




