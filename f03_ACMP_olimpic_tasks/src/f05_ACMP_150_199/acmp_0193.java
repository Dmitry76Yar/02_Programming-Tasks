	package f05_ACMP_150_199;
/*Поиск прямоугольников	(Время: 0,5 сек. Память: 16 Мб Сложность: 34%)
На поле N×M клеток (N строк и M столбцов) положили K прямоугольников один поверх другого в случайном порядке. Длины сторон
прямоугольников выражаются целым числом клеток. Прямоугольники не выходят за границы поля. Границы прямоугольников совпадают
с границами клеток поля.
	Получившуюся ситуацию записали в таблицу чисел (каждой клетке поля соответствует клетка таблицы). Если клетка поля не закрыта
прямоугольником, то в соответствующую клетку таблицы записали число 0. Если же клетка закрыта одним или несколькими
прямоугольниками, то в соответствующую клетку таблицы записали число, соответствующее номеру самого верхнего прямоугольника,
закрывающего эту клетку.
	Требуется написать программу, которая определит положение и размеры прямоугольников. Гарантируется, что во входных данных
содержится информация, которой достаточно для однозначного определения размеров прямоугольников.
	Входные данные
Входной файл INPUT.TXT содержит в первой строке целые числа N, M, K (1 ≤ N ≤ 200, 1 ≤ M ≤ 200, 1 ≤ K ≤ 255). Далее следует N
строк по M чисел в каждой — содержимое таблицы. Все числа в таблице целые, находятся в диапазоне от 0 до K включительно.
	Выходные данные
Выходной файл OUTPUT.TXT должен содержать K строк. Каждая строка должна описывать соответствующий ее номеру прямоугольник
четырьмя числами X1 Y1 X2 Y2 (X1 и Y1 должны описывать координаты левого нижнего угла прямоугольника, а X2 и Y2 — координаты
правого верхнего угла). Числа должны разделяться пробелом.
	Начало координат расположено в левом нижнем углу таблицы. Таким образом, координаты левого нижнего угла поля — (0,0),
правого верхнего — (M,N).

Пример
№	INPUT.TXT	OUTPUT.TXT
1	4 5 2
0 2 2 2 2
0 2 2 2 2
1 1 2 2 2
1 1 0 0 0	0 0 2 2
1 1 5 4
*/

import java.util.*;
import java.io.*;

public class acmp_0193{
public static void main(String[] args) throws IOException {
	Scanner sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));
	int N = sc.nextInt();
	int M = sc.nextInt();
	int K = sc.nextInt();
	
	// Создадим массив stor[K][2],где номер строки - номер прямоугольника, 
    // 0-ой элемент в строке - минимал. строка, 1-ый элемент в строке - максим.строка,
    // 2-ой элемент в строке - минимал. столбец, 3-ий элемент в строке - максимал.столбец
	// 4-ый элемент в строке - площадь (кол-во квардратиков)
	
	int stor[][] = new int[K][5];
	for (int i=0; i<K; i++) Arrays.fill(stor[i],-1);
	for (int i=0; i<K; i++) stor[i][2] = M + 2;
	
	int array[][] = new int[N][M];
	for (int i=0; i<N; i++) {
		for (int j=0; j<M; j++) {
			int a = sc.nextInt();
			array[i][j] = a;
			if (a!=0) {
				if (stor[a-1][0] == -1) stor[a-1][0] = i;
				else stor[a-1][1] = i;
				
				if (j > stor[a-1][3]) stor[a-1][3] = j;
				if (j < stor[a-1][2]) stor[a-1][2] = j;
			}
		}
	}
	
	ArrayList<Integer> emptySquares = new ArrayList<Integer>();
	ArrayList<Integer> foundSquares = new ArrayList<Integer>();
	for (int i=0; i<K; i++) {
		if (stor[i][1] == -1) stor[i][1] = stor[i][0];
		if (stor[i][0] == -1) emptySquares.add(i);
		else foundSquares.add(i);
	}
	
	for (int i=0; i<N; i++) System.out.println(Arrays.toString(array[i]));
	System.out.println();
	for (int i=0; i<K; i++) System.out.println(Arrays.toString(stor[i]));
	System.out.println();
	
	// 0-ой элемент в строке - минимал. строка, 1-ый элемент в строке - максим.строка,
    // 2-ой элемент в строке - минимал. столбец, 3-ий элемент в строке - максимал.столбец
	// X1 и Y1 должны описывать координаты левого нижнего угла прямоугольника, а X2 и Y2 — координаты правого верхнего угла)
	
	PrintWriter o = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	
	if (!emptySquares.isEmpty()) {
		int onlySquare = foundSquares.get(0);
		for (int i=0; i<K; i++) {
			System.out.println((stor[onlySquare][2]) + " " + (N - stor[onlySquare][1] - 1) + " " + (stor[onlySquare][3]  + 1) + " " + (N - stor[onlySquare][0]));
			o.print((stor[onlySquare][2]) + " " + (N - stor[onlySquare][1] - 1) + " " + (stor[onlySquare][3]  + 1) + " " + (N - stor[onlySquare][0]) + "\n");
		}
	}
	else {
		for (int i=0; i<K; i++) {
	//		System.out.println((stor[i][2]) + " " + (stor[i][1]) + " " + (stor[i][3]) + " " + (stor[i][0]));
			System.out.println((stor[i][2]) + " " + (N - stor[i][1] - 1) + " " + (stor[i][3]  + 1) + " " + (N - stor[i][0]));
			o.print((stor[i][2]) + " " + (N - stor[i][1] - 1) + " " + (stor[i][3]  + 1) + " " + (N - stor[i][0]) + "\n");
		}
	}
    o.flush();
    o.close();
    }
}