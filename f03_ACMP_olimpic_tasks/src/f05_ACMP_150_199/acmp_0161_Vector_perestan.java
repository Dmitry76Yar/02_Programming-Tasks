package f05_ACMP_150_199;

	/* Состав вектора и таблицы инверсий для цифровой перестановки P=(5,9,1,8,2,6,4,7,3) показан в следующем примере, где для 
	наглядности индексированы позиции всех элементов:	
	Таблица 1    
	j	1	2	3	4	5	6	7	8	9
	pj	5	9	1	8	2	6	4	7	3
	Vj	0	0	2	1	3	2	4	2	6
	Wj	2	3	6	4	0	2	2	1	9
	Перестановка - p[]
	Вектор инверсии	перестановки - v[]
	Матрица инверсии перестановки - w[] 
	V8=2, потому что слева от элемента P8=7 в перестановке есть 2 элемента P2=9 и P4=8 с большим значением,чем 7. 
	W8=1,потому что слева от элемента со значением 8 (это P4) в перестановке имеется только 1 элемент (P2=9), значение которого больше,
	чем 8. 
	Для любой перестановки значения компонентов вектора и таблицы инверсий связаны следующими соотношениями:
	V1 = Wn = 0; Vj = Wi | i = Pj; Wj = Vi | Pi = j.  */
	
	
	/* Восстановление перестановки по вектору инверсий
	 * http://bigor.bmstu.ru/?cnt/?prn=y/?doc=Comby/comb_inv.mod
		Пример. Восстановить перестановку по таблице инверсий	[3,2,1,5,4]
	ри восстановлении из вектора инверсий V, элементы искомой перестановки P нужно последовательно вычислять справа налево в
	порядке уменьшения индекса, а их значения должны выбираться из списка L упорядоченных по убыванию целых чисел от n до 1.
	При этом значение очередного элемента перестановки pi принимается равным (Vi+1)-му по величине числу списка L. После этого
	выбранное число должно быть исключено из списка. Выполнение алгоритма иллюстрирует следующий пример восстановления
	перестановки P=(3,2,1,5,4) по вектору инверсий V=(0,1,2,0,1):
	p:4->p5 5->p4 1->p3 2->p2 3->p1L:{5 ^4^ 3 2 1}<5 ^3^ 2 1>,<3 2 ^1^>,<3 ^2^>,<^3^>V: 1=V5 0=V4 2=V3 1=V2 0=V1
	    В этом примере символ '^' указывает элемент, который исключается из списка L на каждой итерации, для передачи его значения
	очередному элементу перестановки. В частности, сначала из списка пяти чисел <54321> нужно исключить второй по величине
	элемент (4), так как последний элемент вектора инверсий равен 1, и значение 4 назначается последнему элементу перестановки.
	Аналогичные действия повторяются на всех последующих шагах. */

import java.util.*;
import java.io.*;

public class acmp_0161_Vector_perestan{
	
public static void main(String[] args) throws IOException {
	Scanner sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));
	int N = sc.nextInt();
	
	int vector[] = new int[N+1];
	for (int i =1; i<=N; i++) vector[i] = sc.nextInt();
	System.out.println("vector   " + Arrays.toString(vector));
	
	/* 5
		0 1 2 0 1 */
	
	int res[] = new int[N];
	
	ArrayList<Integer> arr2 = new ArrayList<Integer>();
	for (int i =1; i<=N; i++) arr2.add(i);
	System.out.println(arr2);
	
	int j = N-1;
	for (int i =N; i>0; i--) {
		int a = vector[i];
		int ind = arr2.size() - a -1;
		res[j--] = arr2.get(ind);
		arr2.remove(ind);
		System.out.println("a = " + a + "   ind = " + ind);
		System.out.println(arr2);
	}
	
	System.out.println(Arrays.toString(res));
	
	PrintWriter o = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	for (int h = 0; h<res.length; h++) {
			System.out.print(res[h] + " ->");
			o.print(res[h] +" ");
	}
	o.flush();
	o.close();
}
}




