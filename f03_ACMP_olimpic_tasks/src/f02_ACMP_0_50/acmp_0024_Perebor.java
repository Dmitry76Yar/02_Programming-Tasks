package f02_ACMP_0_50;

/*		Вырубка деревьев		(Время: 1 сек. Память: 16 Мб Сложность: 46%)
Король Флатландии решил вырубить некоторые деревья, растущие перед его дворцом. Деревья перед дворцом короля посажены в ряд, всего
там растет n деревьев, расстояния между соседними деревьями одинаковы.
После вырубки перед дворцом должно остаться m деревьев, и расстояния между соседними деревьями должны быть одинаковыми. Помогите 
королю выяснить, сколько существует способов вырубки деревьев.
Требуется написать программу, которая по заданным числам n и m определит, сколько существует способов вырубки некоторых из n 
деревьев так, чтобы после вырубки осталось m деревьев и соседние деревья находились на равном расстоянии друг от друга.
	Входные данные
Входной файл INPUT.TXT содержит два целых числа n и m (0 ≤ m , n ≤ 1000).
	Выходные данные
В единственную строку выходного файла OUTPUT.TXT нужно вывести одно целое число — искомое число способов.
	Пример
№	INPUT.TXT	OUTPUT.TXT
1	5 3				4
Пояснение к примеру
Если обозначить условно исходное расположение деревьев перед дворцом как «TTTTT», то возможные результаты после вырубки следующие:
«TTT..», «.TTT.», «..TTT», «T.T.T».   */

// ПРОХОДИТ на сайте
import java.io.*;
import java.util.Scanner;

public class acmp_0024_Perebor {
public static void main(String[] args) throws IOException {
	int n = 0;
	int m = 0;
	
	Scanner sc;
	sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));
	while (sc.hasNext()) {
		if (sc.hasNextInt()) n = sc.nextInt(); 
		if (sc.hasNextInt()) m = sc.nextInt(); } 
	
	// 7 3	****TTT		***TTT*		**TTT**		*TTT***		TTT****	 		
	//		*T*T*T*		**T*T*T		T*T*T**		
	// 		T**T**
		
	// 9 3	// 7	******TTT		*****TTT*		****TTT**		***TTT***		**TTT****	 *TTT***** 		TTT******		
			//5		****T*T*T		***T*T*T*		**T*T*T**		*T*T*T***		T*T*T****
			//3		**T**T**T		*T**T**T*		T**T**T**
			//1		T***T***T
			
	//8 3	//6		*****TTT		****TTT*		***TTT**		**TTT***		*TTT****	 TTT***** 				
			//4		***T*T*T		**T*T*T*		*T*T*T**		T*T*T***		
			//2		*T**T**T		T**T**T*		
	
	// 5 4 			*TTTT	TTTT*	
	int count = 0;
	int result = 0;
	int dif = n-m;
	if ((n>=0) & (n <=1000) & (m>=0) & (m<=1000) & (n>=m))  {
		if (n == m) result  = 1;			// Если деревья не вырубается, то лишь один вариант расположения
		else if (m==1) result = n;			// Если одно дерево останется, то 1000 расположений этого дерева среди 1000
		else if (m==0) result = 1;			// Если все деревья вырубаются, то один вариант 
		else {
		// Алгоритм работает след. образом:
		// Для разницы dif = (n-m) существует (n-m+1) расположение вырубленных деревьев по краям.
		// Далее вырубаем между каждым деревом по 1 дереву, т.е. (m-1) деревьев из m ушли внутрь и осталось dif = (n-m) -(m-1) 
		// деревьев для выруба. Для ввода 9 3 останется 4 дерева для выруба, которые можно расположить по краям 5 вар. - (dif + 1)
		// Далее вырубаем 2 дерева внутрт. Для ввода 9 3 останется 2 дерева по краям, которые также можно расположить 3 вариантами
		// Далее снова из dif вычитаем (m-1) и получаем нуль - деревья вырубили внутри, но по краям ничего не осталось  - 1 вариант
		// Если выходим для dif ниже нуля, значить больше не получится вырубить деревья внутри - цикл обрывается 
			
			while (dif > 0) {			
				count = dif +1; 		// Кол-во вариантов краевого размещения
				System.out.print(" count = " + count + ",  dif = " + dif);
				dif = dif - (m-1);		// (m-1) - количество между деревьев
				if (dif == 0) count ++;
				result = result + count;
				System.out.println(" \t dif = " + dif);
			}
				}
	}
	else System.out.println("Неправильный ввод");
	PrintWriter pw;
	pw = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	pw.print(result);
	pw.close();
	System.out.println(result);
	}
}
