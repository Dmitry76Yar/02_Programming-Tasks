package f02_ACMP_0_50;
/* Волосатый бизнес		(Время: 1 сек. Память: 16 Мб Сложность: 32%)
Одного неформала выгнали с работы, и теперь ему надо как-то зарабатывать себе на жизнь. Поразмыслив, он решил, что сможет 
иметь очень неплохие деньги на продаже собственных волос. Известно, что пункты приема покупают волосы произвольной длины 
стоимостью С у.е. за каждый сантиметр. Так как волосяной рынок является очень динамичным, то цена одного сантиметра волос 
меняется каждый день как и курс валют. Неформал является очень хорошим бизнес-аналитиком. Он смог вычислить, какой будет 
цена одного сантиметра волос в каждый из ближайших N дней (для удобства пронумеруем дни в хронологическом порядке от 0 до N-1).
Теперь он хочет определить, в какие из этих дней ему следует продавать волосы, чтобы по истечению всех N дней заработать 
максимальное количество денег. Заметим, что волосы у неформала растут только ночью и вырастают на 1 сантиметр за ночь. 
Следует также учесть, что до 0-го дня неформал с горя подстригся наголо и к 0-му дню длина его волос составляла 1 сантиметр.
	Входные данные
В первой строке входного файла INPUT.TXT записано целое число N (0 < N ≤ 100). Во второй строке через пробел заданы N 
натуральных чисел, не превосходящих 100, соответствующие стоимости C[i] 1 сантиметра волос за каждый i-й день.
	Выходные данные
В единственную строку выходного файла OUTPUT.TXT нужно вывести максимальную денежную сумму, которую может заработать 
неформал за N дней.
	Примеры
№			INPUT.TXT		OUTPUT.TXT
1				5
		73 31 96 24 46			380
2				10
		1 2 3 4 5 6 7 8 9 10	100
3				10
		10 9 8 7 6 5 4 3 2 1	55
 */
 
import java.io.*;
import java.util.Arrays;
import java.util.Scanner;

// УЧИТЫВАЕТСЯ КАЖДЫЙ ЭЛЕМЕНТ ВХОДЯЩЕГО МАССИВА В РАСЧЕТЕ N-ГО ЭЛЕМЕНТА  

public class acmp_0039_Dynamic_pr {
public static void main(String[] args) throws IOException {
	Scanner sc;
	sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));
	int n = sc.nextInt();
	sc.nextLine();
	String str = sc.nextLine();
	String Arr_str[] = str.split(" ");
	int Arr_fig[] = new int[Arr_str.length+1];
	for (int i = 0; i<Arr_str.length; i++) {
		Arr_fig[i+1] = Integer.parseInt(Arr_str[i]);
	}
	/* 73		 31 		96 				24			 		46
	   [73]		[31+73]		[31+73+96]		[31+73+96+24]
	   			[31*2]		[31*2+96]		[31*2+96+24]
	   						[96*3]			[96*3+24]
	   						[73+96*2]		[73+96*2 +24] 
	   						 				[31+73 + 24*2]
	   						 				[31*2 + 24*2]
	   						 				[73 +24*3]
	   						 				[24*4]
	   Алгоритм работает следующим образом:
	   - для удобства исходный массив с 0-м элементом = 0 
	   - создается массив с результатами, в которой записывается МАКСИМАЛЬНОЕ число для каждого шага (для шага на 31 - 31+73)
	   - в этот массив заносятся значение 0го элемента = 0 и 1-го элемента = 73. ВСЕ остальные вычисляются 
	   - для 2-го элемента (31) - начиная с 0-го элемента (0) идет вычисление sum = Arr_fig[i]*(i-j) + Arr_result[j], т.е.
	    		 - сначала sum = Arr_fig[2]*(2-0) + Arr_result[0] = 31*2 + 0 = 64
	    		 - затем sum = Arr_fig[2]*(2-1) + Arr_result[1] = 31*1 + 73 = 104 
	  - для всех отстальных элементов до n аналогично
	   	*/
	System.out.println(Arrays.toString(Arr_fig));
	
	int Arr_result[] = new int[n+1];
	Arr_result[0] = 0;
	Arr_result[1] = Arr_fig[1];
	System.out.println(Arrays.toString(Arr_result));	
	
	for (int i = 2; i<=n; i++) {
		int output = 0;
		int sum = 0;
		for (int j = 0; j<i; j++) {							// Перебор элеменов массива результатов
				sum = Arr_fig[i]*(i-j) + Arr_result[j];
				System.out.println("sum = " + sum);
				if (sum > output) output = sum;
			}
		Arr_result[i] = output;
		System.out.println("Arr_result[" + i + "] = " + Arr_result[i]);
		}
	System.out.println(Arrays.toString(Arr_result));

	PrintWriter pw;
	pw = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	pw.print(Arr_result[n]);
	pw.close();
	}
}
