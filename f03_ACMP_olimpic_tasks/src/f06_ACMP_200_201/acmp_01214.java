package f06_ACMP_200_201;

/* Подсчет баллов	(Время: 1 сек. Память: 16 Мб Сложность: 27%)
Решение каждой задачи заочного тура проверяется на наборе заранее заготовленных тестов. По результатам работы программы на
каждом тесте участнику либо начисляются баллы за этот тест (когда программа выдала правильный ответ), либо не начисляются
(когда во время работы программы произошли ошибки или выданный ответ не верен). Тесты могут иметь разную стоимость.
	Дополнительные баллы начисляются участнику, если его программа прошла все тесты.
	Участник может исправлять свое решение, и посылать его на проверку повторно (при этом решение проверяется на том же наборе
тестов). При этом за каждую попытку из количества набранных по задаче баллов вычитается штраф, который равен 0 при 1-й попытке,
а при каждой следующей возрастает на 2 (то есть 2 при второй, 4 — при третьей, 6 — при четвертой и т.д.).
	Из баллов, полученных участником за каждую из попыток (с учетом начисленных штрафов), выбирается максимальный результат,
который и засчитывается как результат данного участника по этой задаче. Это нужно, в частности, для того, чтобы последующие
попытки не ухудшали уже полученный участником результат по задаче.
	Например, если участник делает первую попытку и набирает 10 баллов, его результат по задаче равен 10 баллов. Пусть на второй
попытке участник посылает решение, которое набирает 8 баллов. С учетом штрафа за эту попытку участник имеет 6 баллов, однако
результат команды по задаче остается равным 10. Пусть с 3-й попытки решение набрало 20 баллов, тогда (с учетом штрафа) результат
участника по задаче становится равен 16 баллам. Наконец, пусть с 4-й попытки решение проходит все тесты, тогда участник получает
сумму баллов за все тесты, плюс призовые баллы за прохождение всех тестов, минус 6 баллов штрафа (если, конечно, эта величина
не меньше 16 баллов, которые уже были у данного участника).
	Напишите программу, которая определяет результат данного участника по этой задаче.
	Входные данные
Во входном файле INPUT.TXT записано сначала число N — количество тестов, на которых проверяются решения данной задачи (1≤N≤100).
Далее идет N натуральных чисел, не превышающих 100, — баллы, которые начисляются за прохождение каждого из тестов. Далее идет
целое число из диапазона от 0 до 100 — количество баллов, которое дополнительно начисляется за прохождение всех тестов.
	Далее идет натуральное число M — количество попыток сдачи задачи (1≤M≤100). После чего идет M наборов по N чисел в каждом,
задающих результаты проверки каждой из M попыток сдачи задачи на тестах. 0 обозначает, что соответствующий тест не пройден,
1 — пройден.
	Выходные данные
В выходной файл OUTPUT.TXT выведите M чисел. i-ое число должно соответствовать результату участника после совершения им первых i
попыток.
	Пример
№	INPUT.TXT	OUTPUT.TXT
1	4
1 2 3 4
5
3
0 0 0 0
1 1 1 1
0 1 0 1			0
				13
				13  	   */

import java.util.*;
import java.io.*;

public class acmp_01214{
public static void main(String[] args) throws IOException {
	Scanner sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));

	ArrayList<Double[][]> arl = new ArrayList<>();
	double a = 0.0;
	while(sc.hasNextLine()) {
	    Double [][] array = new Double[5][3];
	    for (int i =0; i<5; i++) {
	         for (int j =0; j<3; j++) {
	             a = sc.nextDouble();
//	             System.out.print (a + "  ");
	             array[i][j] = a;
	          }
//	          System.out.println();
	     }
	    arl.add(array);
	 }
	  
//	 for (int i =0; i<arl.size(); i++)
//	     System.out.println(Arrays.deepToString(arl.get(i)));
	 
	     // Массив для сохранения результата (числа выпавших эталонов) 
	     // result[i][0] - выпад по углам 15 и 110 углам       result[i][1] - выпад по углам 25-75 углам
	 int result[][] = new int[arl.size()][2];
	 
	 double toCompare = 0;
     double toBeCompared = 0;
     double difference = 0;
     
         // i - массив, с которым сравнивается;
	  for (int i =0; i<arl.size(); i++) {
	         //  j - массив который сравнивается
	       for (int j =0; j<arl.size(); j++) {
	    	  int deviationOn15and110 = 0;
	 		  int deviationOn45_75 = 0;
	                 //  a - перебор координат цвета по строкам
	    	    for (int x=0; x<5; x++) {
	    	    	       //  b - перебор координат цвета по столбцам
	    	    	for (int y =0; y<3; y++) { 
	    	    		toCompare = arl.get(i)[x][y];
	    	    		toBeCompared = arl.get(j)[x][y];
	    	    		difference = toBeCompared - toCompare;
	    	    			// Если строка первая (15 угол) или последняя (110 угол)
	    	    		if ((x == 0) || (x==4)) {
	    	    			    // Если первый столбец (координата dL) 
	    	    			if (y == 0) {
	    	    				       // Если dL <-0,5 или dL >0,5, то плюсуем deviationOn15and110
	    	    				if ((difference < -0.5) || (difference >0.5)) 
	    	    					deviationOn15and110++;
	    	    			}
	    	    			    // Если второй и третий столбцы (координата da и db)
	    	    			else {
	    	    				      // Если dL <-0,3 или dL >0,3, то плюсуем deviationOn15and110
	    	    				if ((difference < -0.3) || (difference >0.3)) 
	    	    					deviationOn15and110++;
	    	    			}
	    	    		}
	    	    		     // Если строка вторая (25 угол), третья (45) или четвертая (75 угол)
	    	    		else {
	    	    			     // Если первый столбец (координата dL) 
	    	    			if (y == 0) {
	    	    				       // Если dL <-0,5 или dL >0,5, то плюсуем deviationOn45_75
	    	    				if ((difference < -0.5) || (difference >0.5)) 
	    	    					deviationOn45_75++;
	    	    			}
	    	    			     // Если второй и третий столбцы (координата da и db)
	    	    			else {
	    	    				      // Если dL <-0,3 или dL >0,3, то плюсуем deviationOn45_75
	    	    				if ((difference < -0.3) || (difference >0.3)) 
	    	    					deviationOn45_75++;
	    	    			}
	    	    		}
	    	    	} // Конец b - перебор координат цвета по столбцам
	    	    }  // Конец a - перебор координат цвета по строкам
	    	           // Если вылет по средним углам, то плюсуем result[i][1]   Если только по крайним углам, то плюсуем result[i][0]
		    	if (deviationOn45_75 >0) result[i][1]++;
		    	else 
		    		if (deviationOn15and110 > 0) result[i][0] ++;
	       } // Конец j - массив который сравнивается
	  } // Конец i - массив, с которым сравнивается;
	  
//	  for (int i=0; i<arl.size(); i++) System.out.println(Arrays.toString(result[i]));
	  
	     // Массив для сохранения результата (числа выпавших эталонов) по возрастаню выпавших эталонов по 25-75 углах
	      // resultFin[i][0] - номер эталона-сравнения
	     // resultFin[i][1] - выпад по углам 15 и 110 углам       
	     // resultFin[i][2] - выпад по углам 25-75 углам
	 int resultFin[][] = new int[arl.size()][3];
	 
	  for (int i=0; i<arl.size(); i++) {
		  int min = arl.size() + 2;
		  int indexOfMin = arl.size() + 2;
		      // находим минимальное число в массиве result и переносим его в первую незанятую ячейку
		  for (int j=0; j<arl.size(); j++) {
			  if (result[j][1] < min ) {
				  min = result[j][1];
				  indexOfMin = j;
			  }
		  }
		  resultFin[i][0] = indexOfMin;
		  resultFin[i][1] = result[indexOfMin][0];
		  resultFin[i][2] = result[indexOfMin][1];
		  result[indexOfMin][1] = arl.size() + 2;
	  }
	  
	       // Массив-результ в строке, чтобы добавить ведущие нули к однозначным цифрам
	  String resultString[][] = new String[arl.size()][3];
	  for (int i=0; i<arl.size(); i++) {
		  if (resultFin[i][0] <10) resultString[i][0] = "0" + Integer.toString(resultFin[i][0]);
		  else resultString[i][0] = Integer.toString(resultFin[i][0]);
		  if (resultFin[i][1] <10) resultString[i][1] = "0" + Integer.toString(resultFin[i][1]);
		  else resultString[i][1] = Integer.toString(resultFin[i][1]);
		  if (resultFin[i][2] <10) resultString[i][2] = "0" + Integer.toString(resultFin[i][2]);
		  else resultString[i][2] = Integer.toString(resultFin[i][2]);
	  }
	  
//	  for (int i=0; i<arl.size(); i++) System.out.println(Arrays.toString(resultFin[i]));
	  
	  StringBuilder sb = new StringBuilder();
	  sb.append("|        Номер      |" + "        Вылетивших          |"  + "        Вылетивших          | " + "\n");
	  sb.append("| эталона-сравнения |" + " эталонов по 25,45 75 углам |"  + " по 15 и 110 углам          |  " + "\n");
	  sb.append("|-----------------------------------------------------------------------------| " + "\n");
	  for (int i=0; i<arl.size(); i++) {
		  sb.append("|        " + resultString[i][0] + "         |              " +  
				  resultString[i][2] + "            |             " + resultString[i][1] + "             | \n");
	  }

	  System.out.println(sb);
	  
	  PrintWriter pw;
	  pw = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	  pw.print(sb);
	  pw.close();
}
}
