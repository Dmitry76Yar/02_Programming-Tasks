package f04_ACMP_101_200;
/* Издевательство	(Время: 1 сек. Память: 16 Мб Сложность: 28%)
Штирлиц ехал на машине, увидел голосующего Бормана, и проехал мимо. Через некоторое время он снова увидел голосующего Бормана, и снова
проехал мимо. Вскоре он опять увидел голосующего Бормана.
- Издевается! - подумал Борман.
- Кольцевая! - догадался Штирлиц.
В городе N площадей. Любые две площади соединены между собой ровно одной дорогой с двусторонним движением. В этом городе живет Штирлиц.
У Штирлица есть хобби - он любит воскресным утром выйти из дома, сесть в машину, выбрать какой-нибудь кольцевой маршрут, проходящий ровно
по трем площадям (то есть сначала он едет с какой-то площади на какую-то другую, потом - на третью, затем возвращается на начальную,
и опять едет по этому маршруту). Он воображает, что где-то на этом пути стоит Борман. И так вот ездит Штирлиц все воскресенье, пока
голова не закружится, и радуется...
	Естественно, что Штирлицу хочется проезжать мимо точки, в которой, как он воображает, стоит Борман, как можно чаще. Для этого,
естественно, выбранный Штирлицем маршрут должен быть как можно короче. Напишите программу, которая выберет оптимальный для Штирлица
маршрут.
	Входные данные
Во входном файле INPUT.TXT записано сначала число N (3 ≤ N ≤ 100), а затем матрица N×N расстояний между площадями (число в позиции i,j
обозначает длину дороги, соединяющей i-ую и j-ую площади). Все числа в матрице (кроме стоящих на главной диагонали) - натуральные, не
превышающие 1000. Матрица симметрична относительно главной диагонали, на главной диагонали стоят 0.
	Выходные данные
В выходной файл OUTPUT.TXT выведите длину оптимального маршрута.
	Пример
№	INPUT.TXT			OUTPUT.TXT
1	5
	0 20 10 30 40
	20 0 30 1 2
	10 30 0 40 1000
	30 1 40 0 21
	40 2 1000 21 0			24		*/

import java.io.*;
import java.util.Arrays;
import java.util.Scanner;

public class acmp_0126 {
public static void main(String[] args) throws IOException {
	Scanner sc = new Scanner(new FileReader("C:\\JavaTXT\\ACMP_0001\\input.txt"));
	int N = sc.nextInt();
	System.out.println(" N = " + N);
	sc.nextLine();
	
	int matriza_smegn[][] = new int[N][N];
	
	for (int i = 0; i<N; i++) {
		for (int j = 0; j<N; j++) {
			matriza_smegn[i][j] = sc.nextInt();
		}
//		sc.nextLine();
	}
	for (int i = 0; i<N; i++)  System.out.println(Arrays.toString(matriza_smegn[i]));
	
	int dist = 5000;
	int minDist = 5000;
	
	for (int i = 0; i<N; i++) {
		for (int j = 0; j<N; j++) {
			if (j<i) {
				for (int k = 0; k<N; k++) {
					if ((k!=j) && (k!=i)) 	{
						dist = matriza_smegn[i][j] + matriza_smegn[j][k] + matriza_smegn[k][i];
						if (minDist > dist) minDist = dist;
						System.out.println("i = " + i + "   j = " + j + "   k = " + k + "   dist = "  + dist);
					}
				}
			}
		}
	}
	
	System.out.println("minDist = " + minDist);
	PrintWriter out = new PrintWriter(new FileWriter("C:\\JavaTXT\\ACMP_0001\\output.txt"));
	out.print(minDist);
    out.flush();
    out.close();
	}
}
